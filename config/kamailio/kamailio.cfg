#!KAMAILIO

#!substdef "!EXTERNAL_LB_ADDR!192.168.45.152!g"
#!substdef "!INTERNAL_LB_ADDR!127.0.0.1!g"
#!substdef "!INTERNAL_ADDR!127.0.0.1!g"
#!substdef "!AUTH_DB_URL!mysql://root:root_password@127.0.0.1:3306/bin_manager!g"
#!substdef "!AUTH_USER_COLUMN!username!g"
#!substdef "!AUTH_DOMAIN_COLUMN!realm!g"
#!substdef "!AUTH_PASSWORD_COLUMN!password!g"
#!substdef "!ASTERISK_CALL_LB!127.0.0.1:5080!g"
#!substdef "!ASTERISK_REGISTRAR_LB!127.0.0.1:5082!g"
#!substdef "!ASTERISK_PORT!5060!g"
#!substdef "!RTPENGINE_SOCKS!ws://127.0.0.1:9101/ng!g"
#!substdef "!HOMER_URI!sip:127.0.0.1:9060!g"
#!substdef "!REDIS_CACHE_ADDR!127.0.0.1!g"


####### Include Defines #########
#!include "defines.cfg"

####### Include Local Config If Exists #########
import_file "kamailio-local.cfg"

####### Defined Values #########

# - flags
#  FLT_ - per transaction (message) flags
#  FLB_ - per branch flags
#!define FLT_ACC 1
#!define FLT_ACCMISSED 2
#!define FLT_ACCFAILED 3
#!define FLT_NATS 5

#!define FLB_NATB 6
#!define FLB_NATSIPPING 7

####### Global Parameters #########

### LOG Levels: 3=DBG, 2=INFO, 1=NOTICE, 0=WARN, -1=ERR
debug=2
log_stderror=no

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

// reply_to_via = 1

// number of SIP routing processes for each UDP socket
children=2
// number of SIP routing processes for all TCP/TLS sockets
tcp_children=4

/* Because we are using the tcp connection with mulitple kamailios,
 * we can not support rport. */
force_rport=no

// external listeners
listen=udp:EXTERNAL_LB_ADDR:5060 advertise EXTERNAL_LB_ADDR:5060
listen=tcp:EXTERNAL_LB_ADDR:5060 advertise EXTERNAL_LB_ADDR:5060
listen=tcp:EXTERNAL_LB_ADDR:80   advertise EXTERNAL_LB_ADDR:80
listen=tls:EXTERNAL_LB_ADDR:443  advertise EXTERNAL_LB_ADDR:443
listen=tls:EXTERNAL_LB_ADDR:5061 advertise EXTERNAL_LB_ADDR:5061

// internal listeners
listen=udp:INTERNAL_LB_ADDR:5060
listen=tcp:INTERNAL_LB_ADDR:5060
listen=udp:INTERNAL_ADDR:5060
listen=tcp:INTERNAL_ADDR:5060

/* Add IP address as alias so that requests to sip:xxx@192.168.45.152
 * are recognized as "myself" and properly routed to local users */
alias=EXTERNAL_LB_ADDR

/* life time of TCP connection when there is no traffic
 * - a bit higher than registration expires to cope with UA behind NAT */
tcp_connection_lifetime=3605

/* upper limit for TCP connections (it includes the TLS connections) */
tcp_max_connections=2048

/* allow zero size of content length for health-check */
tcp_accept_no_cl=yes

enable_tls=yes

/* upper limit for TLS connections */
tls_max_connections=2048

####### Modules Section ########

/* set paths to location of modules */
# mpath="/usr/local/lib64/kamailio/modules/"

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "counters.so"
loadmodule "db_mysql.so"
loadmodule "auth.so"
loadmodule "auth_db.so"

loadmodule "lwsc.so"
loadmodule "rtpengine.so"
loadmodule "sdpops.so"
loadmodule "xhttp.so"
loadmodule "htable.so"
loadmodule "pike.so"
loadmodule "rtpproxy.so"
loadmodule "dispatcher.so"
loadmodule "tls.so"
loadmodule "websocket.so"
loadmodule "nathelper.so"
// loadmodule "siptrace.so"
loadmodule "textopsx.so"
loadmodule "ndb_redis.so"
loadmodule "permissions.so"

# ----------------- setting module-specific parameters ---------------

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)
/* set the path to RPC fifo control file */
# modparam("jsonrpcs", "fifo_name", "/var/run/kamailio/kamailio_rpc.fifo")
/* set the path to RPC unix socket control file */
# modparam("jsonrpcs", "dgram_socket", "/var/run/kamailio/kamailio_rpc.sock")

# ----- ctl params -----
/* set the path to RPC unix socket control file */
# modparam("ctl", "binrpc", "unix:/var/run/kamailio/kamailio_ctl")

# ----- auth_db params -----
modparam("auth_db", "version_table", 0)
modparam("auth_db", "calculate_ha1", 1)
modparam("auth_db", "db_url", "AUTH_DB_URL")
modparam("auth_db", "user_column", "AUTH_USER_COLUMN")
modparam("auth_db", "domain_column", "AUTH_DOMAIN_COLUMN")
modparam("auth_db", "password_column", "AUTH_PASSWORD_COLUMN")
modparam("auth_db", "use_domain", 1)

# ----- rr params -----
# set next param to 1 to add value to ;lr param (helps with some UAs)
modparam("rr", "enable_full_lr", 0)
# do not append from tag to the RR (no need for this script)
modparam("rr", "append_fromtag", 0)

# ----- pike params -----
modparam("pike", "sampling_time_unit", 2)
modparam("pike", "reqs_density_per_unit", 5)
modparam("pike", "remove_latency", 4)

# ----- htable params -----
/* ip ban htable with autoexpire after 3 minutes */
modparam("htable", "htable", "ipban=>size=8;autoexpire=180;")

#!ifdef WITH_DEBUG
# ----- debugger params -----
modparam("debugger", "cfgtrace", 0)
modparam("debugger", "log_level_name", "exec")
#!endif

# ----- rtpengine params
modparam("rtpengine", "wsapi", "lwsc")
modparam("rtpengine", "rtpengine_sock", "RTPENGINE_SOCKS")
modparam("rtpengine", "read_sdp_pv",  "$var(sdp_to_rtpengine)")
modparam("rtpengine", "write_sdp_pv", "$var(sdp_from_rtpengine)")

# ----- xhttp parmas
modparam("xlog", "buf_size", 8192)

# ----- dispatcher params
modparam("dispatcher", "ds_ping_interval", 3)
modparam("dispatcher", "ds_probing_mode", 3)
modparam("dispatcher", "ds_ping_reply_codes", "class=2;code=401")
modparam("dispatcher", "ds_default_socket", "tcp:INTERNAL_ADDR:5060")

# ----- tls params
modparam("tls", "config", "/config/tls.cfg")
modparam("tls", "tls_debug", 10)
modparam("tls", "tls_log", 10)

# ----- siptrace params
// NOTE:
// we can not use sip trace for now.
// Because capturing the SIP message from the Kamailio allows
// capture the TLS(WSS) encryped messages.
// But when the siptrace module sending a HEP message to the homer server,
// it uses UDP always. Because of UDP's limitation, we can not send a message
// bigger than UDP's MTU. And in the cloud env(GCP), it is hard to increase
// the UDP's MTU.
// So we don't use the siptrace at here.
// modparam("siptrace", "trace_on", 1)
// modparam("siptrace", "duplicate_uri", "HOMER_URI")
// modparam("siptrace", "trace_to_database", 0)
// modparam("siptrace", "hep_mode_on", 1)
// modparam("siptrace", "hep_version", 3)
// modparam("siptrace", "trace_mode", 1)
// modparam("siptrace", "trace_flag", 22)

# ------ sl params
modparam("sl", "bind_tm", 0)

# ------ ndb_redis params
modparam("ndb_redis", "server", "name=cache;addr=REDIS_CACHE_ADDR;port=6379;db=1")

# ----- permissions params
modparam("permissions", "address_file", "/config/pstn_whitelist.txt")

####### Routing Logic ########
/* Main SIP request routing logic
 * - processing of any incoming SIP request starts with this route
 * - note: this is the same as route { ... } */
request_route {
  xlog("L_INFO", "request_route. $si:$sp -> $Ri:$Rp\n");

  # init request.
  route(request_init);

  # loop detect
  route(request_loop_detect);

  # check where the request coming from.
  if (src_ip == INTERNAL_LB_ADDR/8) {
    route(request_from_internal);
  }
  else {
    route(request_from_external);
  }
}

// request_init validates the request breifly.
// exit here if the request is not valid(checks breifly).
route[request_init] {
  // checks scanners
  if ($ua =~ "friendly-scanner|sipcli|VaxSIPUserAgent") {
    # silent drop for scanners - uncomment next line if want to reply
    # sl_send_reply("200", "OK");
    exit;
  }

  // For the options, just return the 200
  // if(is_method("OPTIONS") && uri==myself && $rU==$null) {
  if (is_method("OPTIONS")) {
    sl_send_reply("200", "Keepalive");
    exit;
  }

  // // For the register/subscribe, just exit here.
  // if (is_method("REGISTER") || (is_method("SUBSCRIBE"))) {
  //   // // test. must be deleted
  //   // sl_send_reply("200", "OK");
  //   exit;
  // }

  // wrong SIP message
  if (!sanity_check()) {
    xerr("Malformed SIP message from $si:$sp\n");
    exit;
  }

  // // The message is too big
  // if ($msg(body_len) > 8000) {
  //   xerr("The message is too big. $msg(body_len)\n");
  //   sl_send_reply("513", "Message too large");
  //   exit;
  // }

}

// request_from_external_loop_detect detects loop for request.
// If it detects loop, just exit.
route[request_from_external_loop_detect] {

  if (dst_ip == INTERNAL_ADDR) {
    xlog("L_INFO", "Loop detected. Invalid dst. dst: $Ri:$Rp, src: $si:$sp\n");
    exit;
  }

  if (uri != myself) {
    return;
  }

  if (!has_totag()) {
    return;
  }

  xlog("L_INFO", "Loop detected. $si:$sp\n");
  exit;
}

// request_from_internal_loop_detect detects loop for request.
// If it detects loop, just exit.
route[request_from_internal_loop_detect] {

  if (uri != myself) {
    return;
  }

  xlog("L_INFO", "Loop detected. $si:$sp\n");
  exit;
}

// request_from_internal_rtpengine controls the rtpengine for the request from the internal request.
// It updates the sdp by the request(offer/answer/delete).
route[request_from_internal_rtpengine] {

  if (is_method("BYE")) {
    rtpengine_delete();
    return;
  }

  if (!has_body("application/sdp")) {
    return;
  }

  // set sdp buffer to rtpengine
  $var(sdp_to_rtpengine) = $rb;

  // rtpengine contorl
  if (has_totag()) {
    // existed call
    if (is_method("INVITE")) {

      if (!redis_cmd("cache", "GET kamailio.$ci:sdp_transport", "res")) {
        xlog("L_WARN", "[$ci] Could not find cached sdp transport.\n");
      }

      if ($nh(P) =~ "(i?)WSS" || $nh(P) =~ "(i?)WS") {
        rtpengine_offer(
          "replace-origin "
          "replace-session-connection "
          "direction=priv "
          "direction=pub "
          "codec-mask=all "
          "codec-transcode=OPUS "
          "codec-except=VP8 "
          "ICE=remove "
          "$redis(res=>value) "
        );
      }
      else {
        rtpengine_offer(
          "replace-origin "
          "replace-session-connection "
          "direction=priv "
          "direction=pub "
          "codec-mask=all "
          "codec-transcode=PCMU "
          "codec-transcode=PCMA "
          "codec-transcode-telephone-event "
          "codec-except=VP8 "
          "ICE=remove "
          "$redis(res=>value) "
          "rtcp-mux-accept "
        );
      }
    }
    else if (is_method("ACK")) {
      rtpengine_answer(
        "replace-origin "
        "replace-session-connection "
        "ICE=remove "
      );
    }
  }
  else {
    // new outbound call request from internal
    xlog("L_INFO", "[$ci] Manging the rtpengine for new outbound call request from internal. sdp_transport: $hdr(VBOUT-SDP_Transport), transport: $dP, nexthop: $nh(P)");

    // new connection
    if (!redis_cmd("cache", "SET kamailio.$ci:sdp_transport $hdr(VBOUT-SDP_Transport)", "res")
      || !redis_cmd("cache", "EXPIRE kamailio.$ci:sdp_transport 86400", "tmp")
    ) {
      xlog("L_WARN", "[$ci] Could not set sdp transport into cache.\n");
    }
    xlog("L_INFO", "[$ci] Succesfully cached the requested sdp_transport type. $hdr(VBOUT-SDP_Transport), next_transport: $nh(P)\n");

    // rtpengine setting
    if ($nh(P) =~ "(i?)WSS" || $nh(P) =~ "(i?)WS") {
      rtpengine_offer(
        "replace-origin "
        "replace-session-connection "
        "direction=priv "
        "direction=pub "
        "codec-mask=all "
        "codec-transcode=OPUS "
        "codec-except=VP8 "
        "codec-offer-telephone-event "
        "ICE=force "
        "$hdr(VBOUT-SDP_Transport) "
        "rtcp-mux-accept "
        "SDES=off "
      );
    }
    else {
      rtpengine_offer(
        "replace-origin "
        "replace-session-connection "
        "direction=priv "
        "direction=pub "
        "codec-mask=all "
        "codec-transcode=PCMU "
        "codec-transcode=PCMA "
        "codec-transcode-telephone-event "
        "codec-except=VP8 "
        "codec-offer=telephone-event "
        "ICE=remove "
        "$hdr(VBOUT-SDP_Transport) "
        "rtcp-mux-accept "
      );
    }
  }

  // get sdp buffer from rtpengine
  set_body($var(sdp_from_rtpengine), "application/sdp");
}

// request_loop_detect detects loop for request.
// If it detects loop, just exit.
// Modified for local dev: also check source port to avoid false positives
// when softphone and Kamailio share the same host IP
route[request_loop_detect] {
  if (dst_ip == myself && src_ip == myself && ($sp == 5060 || $sp == 5061 || $sp == 443 || $sp == 80 || $sp == 8080)) {
    xlog("L_INFO", "Loop detected. $si:$sp\n");
    exit;
  }
}

// reply_route handles reply messages.
reply_route {
  xlog("L_INFO", "reply_route: $rs $rr from $si:$sp to $Ri:$Rp method=$rm call_id=$ci\n");

  // Check if this is a transaction-managed reply
  // t_check_trans() returns 1 if this reply belongs to an active transaction
  $var(t_check) = t_check_trans();
  xlog("L_INFO", "reply_route: t_check_trans() returned $var(t_check)\n");

  if ($var(t_check) == 1) {
    xlog("L_INFO", "reply_route: Reply belongs to active transaction, letting tm handle it\n");
    // Let tm module handle the reply automatically - don't interfere
    return;
  }

  xlog("L_INFO", "reply_route: No active transaction ($var(t_check)), processing as stateless reply\n");

  if (src_ip == INTERNAL_LB_ADDR/8) {
    route(reply_from_internal);
  }
  else {
    route(reply_from_external);
  }

}

// reply_from_external_loop_detect detects loop for response from external.
// If it detects loop, just exit.
route[reply_from_external_loop_detect] {
  if (dst_ip == INTERNAL_ADDR) {
    xlog("L_INFO", "Loop detected. Invalid dst. dst: $Ri:$Rp, src: $si:$sp\n");
    exit;
  }

  return;
}

// reply_from_internal_loop_detect detects loop for response from internal.
// If it detects loop, just exit.
route[reply_from_internal_loop_detect] {
  // TODO:
  return;
}

// reply_from_internal_rtpengine
route[reply_from_internal_rtpengine] {
  // set sdp buffer to rtpengine
  $var(sdp_to_rtpengine) = $rb;

  // rtpengine contorl
  if (is_method("BYE")) {
    rtpengine_delete();
    return;
  }

  if (!has_body("application/sdp")) {
    return;
  }

  if (!redis_cmd("cache", "GET kamailio.$ci:sdp_transport", "res")) {
    xlog("L_WARN", "[$ci] Could not find cached sdp transport.\n");
  }

  rtpengine_answer(
    "replace-origin "
    "replace-session-connection "
    "direction=priv "
    "direction=pub "
    "$redis(res=>value) "
  );

  // get sdp buffer from rtpengine
  set_body($var(sdp_from_rtpengine), "application/sdp");

  return;
}

// reply_from_external_rtpengine
route[reply_from_external_rtpengine] {

  // rtpengine contorl
  if (is_method("BYE")) {
    rtpengine_delete();
    return;
  }

  if (!has_body("application/sdp")) {
    return;
  }

  // set sdp buffer to rtpengine
  $var(sdp_to_rtpengine) = $rb;

  rtpengine_answer(
    "replace-origin "
    "replace-session-connection "
    "direction=pub "
    "direction=priv "
    "RTP/AVPF "
  );

  // get sdp buffer from rtpengine
  xlog("L_INFO", "Setting the updated sdp buffer. $var(sdp_from_rtpengine)\n");
  set_body($var(sdp_from_rtpengine), "application/sdp");

  return;
}

// request_from_external_ban_detect evaluate the given source ip is banned or not.
route [request_from_external_ban_detect] {
  // check the new invite only
  if ((!is_method("INVITE")) || (has_totag())) {
    return;
  }

  // Skip pike checking for local network (sandbox testing)
  if ($si =~ "^192\.168\.") {
    xlog("L_INFO", "Local network IP $si - skipping pike check\n");
    return;
  }

  if ($sht(ipban=>$si) != $null)
  {
     # ip is already blocked - keep the node warm
     // we don't do this for now. we need more traffics.
     // pike_check_req();
     xlog("L_INFO", "request from blocked IP - $rm from $fu (IP:$si:$sp)\n");
     exit;
  }

  if (pike_check_req() != 1) {
     $sht(ipban=>$si) = 1;
     xalert("ALERT: pike block $rm from $fu (IP:$si:$sp)\n");
     exit;
  }
}

route[request_from_external_init_connection] {
  # Check if request is from internal Docker network (Asterisk containers)
  # Skip domain validation for trusted internal services
  if ($si =~ "^172\.28\.") {
    xlog("L_INFO", "Internal Docker traffic: Accepted $si for $rd\n");
    append_hf("VB-Source: $si\r\n");
    append_hf("VB-Transport: $proto\r\n");
    # For internal traffic to IP addresses, derive the domain from the registered contact
    # or use a default voipbin domain
    if ($rd =~ "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+") {
      # Request is to raw IP - this is from Asterisk dialing a softphone directly
      # Set the flag to indicate this should be relayed directly, not to Asterisk dispatcher
      setflag(10);  # FLT_INTERNAL_OUTBOUND
      append_hf("VB-Domain: internal.voipbin.net\r\n");
    } else {
      append_hf("VB-Domain: $rd\r\n");
    }
    return;
  }

  # Check if request is for pstn.* domain
  if ($rd =~ "^pstn\.") {
    # Check if source IP is in PSTN whitelist (group 1)
    if (allow_source_address("1")) {
      xlog("L_INFO", "PSTN whitelist: Accepted $si for $rd\n");
      append_hf("VB-Source: $si\r\n");
      append_hf("VB-Transport: $proto\r\n");
      append_hf("VB-Domain: pstn.voipbin.net\r\n");
      return;
    }
    # IP not whitelisted for PSTN
    xlog("L_WARN", "PSTN whitelist: Rejected $si for $rd\n");
    sl_send_reply("403", "Forbidden");
    exit;
  }

  # Non-PSTN traffic: normal auth flow
  // validate requested domain
  route(validate_requested_domain);

  // validate the authentication
  route(validate_authentication);

  // add VB(voipbin) headers
  append_hf("VB-Source: $si\r\n");
  append_hf("VB-Transport: $proto\r\n");

  // add the VB-Domain header. If it's not *.voipbin.net, add the default service domain.
  $var(voipbin_domain) = ".voipbin.net";
  $var(rdlen) = $(rd{s.len});
  $var(tmplen) = $var(rdlen) - $(var(voipbin_domain){s.len});

  if (($var(rdlen) < $(var(voipbin_domain){s.len})) || ($(rd{s.strip,$var(tmplen)}) != $var(voipbin_domain))) {
    xlog("L_INFO", "[$ci] The requested domain is not acceptable. domain: $rd\n");
    exit;
  }

  append_hf("VB-Domain: $rd\r\n");
}

// request_from_external_contact controls the request's contact address.
// it adds the alias address to the contact address if it needs
route[request_from_external_contact] {
  if (!is_present_hf("Contact")) {
    // the contact header does not exist.
    // nothing to do
    return;
  }

  if (nat_uac_test(64)) {
    // we are modifying the contact header here.
    // because for the webrtc(websocket connection) call need to set the correct outbound proxy
    // where the holding the websocket connection.
    if (!set_contact_alias()) {
      xlog("L_ERR", "Could not set aliasing the contact <$ct>.\n");
      sl_send_reply("400", "Bad Request");
      exit;
    }

    msg_apply_changes();

    $var(tmp) = $(ct{nameaddr.uri});
    remove_hf("Contact");
    append_hf("Contact: <$var(tmp);outbound_proxy=INTERNAL_ADDR>\r\n", "CSeq");

    return;
  }

  if (has_totag()) {
    return;
  }

  // if the request has no recrod-route, add the contact alias
  if (!is_present_hf("Record-Route")) {
    if (!add_contact_alias()) {
      xerr("Could not aliasing the contact <$ct>\n");
      send_reply("400", "Bad request");
      exit;
    };
  }
}

// request_from_external_rtpengine controls the rtpengine for the request from the external network.
// It updates the sdp by the request(offer/answer/delete).
route[request_from_external_rtpengine] {

  if (is_method("BYE")) {
    rtpengine_delete();
    return;
  }

  if (!has_body("application/sdp")) {
    return;
  }

  // caching the sdp_transport info
  sdp_transport("$avp(sdp_transport)");
  if (!redis_cmd("cache", "SET kamailio.$ci:sdp_transport $avp(sdp_transport)", "res")
    || !redis_cmd("cache", "EXPIRE kamailio.$ci:sdp_transport 86400", "tmp")
  ) {
    xlog("L_WARN", "[$ci] Could not set sdp transport into cache.\n");
  }
  xlog("L_INFO", "[$ci] Cached the requested sdp_transport type. $avp(sdp_transport)\n");

  // set sdp buffer to rtpengine
  $var(sdp_to_rtpengine) = $rb;

  // rtpengine contorl
  if (is_method("INVITE") || is_method("UPDATE")) {
    rtpengine_offer(
      "replace-origin "
      "replace-session-connection "
      "direction=pub "
      "direction=priv "
      "codec-mask=all "
      "codec-transcode=PCMU "
      "codec-transcode-telephone-event "
      "codec-except=VP8 "
      "ICE=remove "
      "RTP/AVPF "
      "rtcp-mux-accept "
    );
  }
  else if (is_method("ACK")) {
    rtpengine_answer(
      "replace-origin "
      "replace-session-connection "
      "ICE=remove "
    );
  }

  // update the sdp buffer from rtpengine
  set_body($var(sdp_from_rtpengine), "application/sdp");
}

// validate_requested_domain validates the requested domain name from the request-uri.
// If the requested domain is not valid, exit it without response.
// It adds VB-Domain header for requested domain.
route[validate_requested_domain] {

  // we allow the traffic without destination validation for now.
  // because we need a test metric.
  return;

  // checks the domain length.
  // sip.voipbin.net
  // it has to be over 15 characters.
  $var(domain_len) = $(rd{s.len});
  if ($var(domain_len) < 15) {
    xlog("L_INFO", "Invalid requested domain. $rd");
    exit;
  }

  // gets the domain name.
  // the only echo.voipbin.net or *.sip.voipbin.net are valid.
  $var(domain) = $(rd{re.subst,/^(.*)@(\.voipbin.net)/\1/});
  if ($var(domain) != "echo" && $var(domaon) != "sip") {
    xlog("L_INFO", "Invalid requested domain. $rd");
    exit;
  }
}

// validate_authentication validates the request's authentication.
route[validate_authentication] {
  if ($rd =~ ".trunk.voipbin.net" || $rd =~ ".registrar.voipbin.net") {
    if (!auth_check("$fd", "registrar_sip_auths", "0")) {
      xlog("L_INFO", "Need an auth check. Sending back auth challenge. fd=>$fd");
      auth_challenge("$fd", "1");
      exit;
    }
    return;
  }
}

# route[request_from_internal] sends the request from internal network
# to the external network.
# send it to the external network using external load balancer address.
route[request_from_internal] {
  xlog("L_INFO", "request_from_internal. $si:$sp -> $Ri:$Rp\n");

  // loop detect
  route(request_from_internal_loop_detect);

  // do rtpengine control
  route(request_from_internal_rtpengine);

  // set the rout related header
  if (has_totag()) {
    // established connection.
    // perform the routing using the route header
    loose_route();
  }
  else {
    // new connection request.
    // add record-route headers
    record_route();
  }

  if ($nh(P) == $null || $nh(P) == "") {
    xlog("L_INFO", "[$ci] Could not find destination transport protocol. Use default: UDP\n");
    force_send_socket(udp:EXTERNAL_LB_ADDR:5060);
  }

  route(request_from_internal_ruri_handle);

  // forward
  // Use stateful relay for INVITE to properly handle responses
  if (is_method("INVITE") && !has_totag()) {
    xlog("L_INFO", "request_from_internal: Using t_relay() for new INVITE to $ru (dst=$du)\n");
    t_on_reply("MANAGE_REPLY");
    if (!t_relay()) {
      xlog("L_ERR", "request_from_internal: t_relay() failed for INVITE\n");
      sl_reply_error();
    }
    exit;
  }

  forward();
  xlog("L_INFO", "request_from_internal. Forwarding the message.");
}

route[request_from_internal_ruri_handle] {

  if (!handle_ruri_alias()) {
    xerr("Bad alias <$ru>\n");
    sl_send_reply("400", "Bad Request");
    exit;
  }

}

# route[request_from_external] sends the request from external network
# to the internal network.
# send it to the internal Asterisk load balancer.
route[request_from_external] {
  xlog("L_INFO", "request_from_external. $si:$sp -> $Ri:$Rp\n");

  // loop detect
  route(request_from_external_loop_detect);

  // check the ip has ban or not
  route(request_from_external_ban_detect);

  // set force_rport for any other then UDP
  if (proto != UDP) {
    force_rport();
  }

  // handle the contact address
  route(request_from_external_contact);

  // Check if request is from internal Docker network (Asterisk containers) to an IP address
  // This means Asterisk is dialing out to a softphone - relay directly without dispatcher
  if (($si =~ "^172\.28\.") && ($rd =~ "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+")) {
    setflag(10);  # FLT_INTERNAL_OUTBOUND
    xlog("L_INFO", "Internal outbound: Setting direct relay flag for $si -> $rd\n");
  }

  // destination config
  if (has_totag()) {
    // established connection
    loose_route();
  } else {
    // add record-route headers
    record_route();

    // Check if this is an outbound call from internal Asterisk (flag 10)
    // If so, relay directly to the destination without going through dispatcher
    if (isflagset(10)) {
      xlog("L_INFO", "Internal outbound: Relaying directly to $ru\n");
      // Don't use dispatcher - relay to the destination as-is
    } else {
      // new request. select asterisk using dispatcher
      if (is_method("REGISTER")) {
        if (!ds_select_dst(2, 4)) {
          xerr("Could not get asterisk address for request_from_external REGISTER. $Ru, $si\n");
          exit;
        }
      } else {
        if (!ds_select_dst(1, 4)) {
          xerr("Could not get asterisk address for request_from_external. $Ru, $si\n");
          exit;
        }
      }
    }
  }

  // check new call connection request
  if (is_method("INVITE") && (!has_totag())) {
    // new connection request
    route(request_from_external_init_connection);
  }

  // rtpengine control
  route(request_from_external_rtpengine);

  // For direct relay to external endpoints (internal outbound), use external socket
  if (isflagset(10)) {
    xlog("L_INFO", "Internal outbound: Using external socket for direct relay\n");

    // Handle alias parameter in Request-URI to set proper destination
    // The Request-URI from Asterisk has alias=IP~port~transport that needs processing
    if ($ru =~ ";alias=") {
      if (!handle_ruri_alias()) {
        xlog("L_ERR", "Internal outbound: Failed to handle ruri alias for $ru\n");
      } else {
        xlog("L_INFO", "Internal outbound: Processed alias, destination is now $du\n");
      }
    }

    if (proto == UDP) {
      force_send_socket(udp:EXTERNAL_LB_ADDR:5060);
    } else {
      force_send_socket(tcp:EXTERNAL_LB_ADDR:5060);
    }
  } else {
    # use the internal socket to send to Asterisk
    if (proto == UDP) {
      force_send_socket(udp:INTERNAL_LB_ADDR:5060);
    } else {
      force_send_socket(tcp:INTERNAL_ADDR:5060);
    }
  }

  // forward
  // For direct relay to external endpoints, use stateful relay for proper reply routing
  if (isflagset(10)) {
    xlog("L_INFO", "Using t_relay() for direct relay to $ru (dst=$du)\n");
    // Register reply callback BEFORE t_relay() - this is critical!
    t_on_reply("MANAGE_REPLY");
    if (!t_relay()) {
      xlog("L_ERR", "t_relay() failed for direct relay\n");
      sl_reply_error();
    }
    xlog("L_INFO", "t_relay() returned, transaction created\n");
    exit;  // Don't fall through after t_relay()
  } else {
    forward();
  }

  xlog("L_INFO", "request_from_external. done. $si:$sp -> $Ri:$Rp\n");
}

// reply_from_internal sets the external socket to use to send
// the response.
route[reply_from_internal] {

  if (is_method("OPTIONS")) {
    exit;
  }

  xlog("L_INFO", "reply_from_internal. start. $si:$sp -> $Ri:$Rp\n");

  // loop detect
  route(reply_from_internal_loop_detect);

  // rtpengine contorl
  route(reply_from_internal_rtpengine);

  xlog("L_INFO", "reply_from_internal. forwarding. $si:$sp -> $Ri:$Rp\n");
}

// reply_from_external sets the internal socket to use to send
// the response.
route[reply_from_external] {

  if (!has_totag()) {
    exit;
  }

  // loop detect
  route(reply_from_external_loop_detect);

  // rtpengine contorl
  route(reply_from_external_rtpengine);

  // set contact for webrtc(websocket) connection
  if (nat_uac_test(64) && is_present_hf("Record-Route") && is_present_hf("Contact")) {
    // we are modifying the contact header here.
    // because for the webrtc(websocket connection) call need to set the correct outbound proxy
    // where the holding the websocket connection.
    if (!set_contact_alias()) {
      xlog("L_ERR", "Could not set aliasing the contact <$ct>.\n");
      sl_send_reply("400", "Bad Request");
      exit;
    }

    msg_apply_changes();

    $var(tmp) = $(ct{nameaddr.uri});
    remove_hf("Contact");
    append_hf("Contact: <$var(tmp);outbound_proxy=INTERNAL_ADDR>\r\n", "CSeq");
  }

  # reply came from external
  # use the internal socket to send
  xlog("L_INFO", "reply_from_external. Forwarding the message to $du");
}

// onreply_route for handling replies when using t_relay()
onreply_route[MANAGE_REPLY] {
  xlog("L_INFO", "MANAGE_REPLY: Reply $rs $rr from $si:$sp\n");

  // Handle RTPEngine for replies with SDP
  if (has_body("application/sdp")) {
    if (!redis_cmd("cache", "GET kamailio.$ci:sdp_transport", "res")) {
      xlog("L_WARN", "[$ci] Could not find cached sdp transport in MANAGE_REPLY.\n");
    }

    rtpengine_answer(
      "replace-origin "
      "replace-session-connection "
      "SIP-source-address "
      "ICE=remove "
      "$var(sdp_transport) "
    );
  }
}


// event_route[xhttp:request] handles request via http
event_route[xhttp:request] {

  if ($hu =~ "^/health-check") {
    xhttp_reply("200", "OK", "text/html", "<html><body>OK - [$si:$sp]</body></html>");
    exit;
  }

  if ($Rp != 80 && $Rp != 443) {
    xhttp_reply("403", "Forbidden", "", "");
    exit;
  }

  if (!($hdr(Upgrade) =~ "websocket") || !($hdr(Connection) =~ "Upgrade") || !($rm =~ "GET")) {
    sl_send_reply("403", "Forbidden");
    exit;
  }

  # Validate Host - make sure the client is using the correct
  # alias for WebSockets
  if (!($hdr(Host) =~ "voipbin.net$")) {
  // if ($hdr(Host) == $null || $hdr!is_myself("sip:" + $hdr(Host))) {
    xlog("L_WARN", "[$si:$sp] Bad host $hdr(Host)\n");
    xhttp_reply("403", "Forbidden", "", "");
    exit;
  }

  # Optional... validate Origin - make sure the client is from an
  # authorised website.  For example,
  #
  # if ($hdr(Origin) != "https://example.com"
  #  && $hdr(Origin) != "https://example.com") {
  #  xlog("L_WARN", "Unauthorised client $hdr(Origin)\n");
  #  xhttp_reply("403", "Forbidden", "", "");
  #  exit;
  # }

  # Optional... perform HTTP authentication

  # ws_handle_handshake() exits (no further configuration file
  # processing of the request) when complete.
  if (!ws_handle_handshake()) {
    xlog("L_WARN", "[$si:$sp] Could not finish the websocket handshake. $si\n");
    exit;
  }
  xlog("L_INFO", "Finished websocket handshake. websocket_id: $ws_conid, si: $si, sp: $sp\n");

  # Optional... cache some information about the
  # successful connection
  // $sht(websockets=>$si::$sp) = $ws_conid;
}

event_route[websocket:closed] {
  xlog("L_INFO", "WebSocket connection with id $ws_conid has closed.\n");
}
